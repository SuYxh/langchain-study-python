我们来构建一个结合 **Example Selectors** 和 **FAISS** 的实用案例。
这个组合非常强大，它解决了两个核心问题：
1.  **示例太多**：如果我有几百个示例，全部放进 Prompt 会消耗大量 Token，甚至超出模型限制。
2.  **示例不相关**：对于用户的特定问题，可能只有几个示例是真正相关的。无关的示例甚至会干扰模型。
**FAISS + Example Selector** 的解决方案是：**根据用户输入的语义，动态地从大量示例中选出最相关的 K 个**。
---
## 场景设定：智能代码生成助手
我们要创建一个代码生成助手，它有一个包含各种代码片段的“知识库”。当用户提出需求时，它会自动找到最相关的代码示例，然后基于这些示例来生成新的代码。
### 核心流程（智能图书管理员比喻）
1.  **图书馆（示例池）**：我们有一个包含各种代码示例的大图书馆。
2.  **读者请求（用户输入）**：用户说：“我想写一个函数”。
3.  **智能管理员（嵌入模型）**：管理员不仅懂文字，还懂文字的**含义**。他知道“写一个函数”和“定义一个方法”是相似的。
4.  **快速索引系统（FAISS）**：管理员不是一本一本地翻书，而是通过一个超快的索引系统，立刻找到与“函数”最相关的几本书。
5.  **推荐书籍（Example Selector）**：管理员把最相关的 2 本书（示例）递给你。
6.  **学习并创作（LLM）**：你（LLM）看了这 2 个示例后，胸有成竹地写出了新的代码。
---
### 完整代码案例
#### 1. 准备工作：安装依赖
```bash
pip install langchain langchain-openai faiss-cpu tiktoken
# 如果你有 GPU，可以使用 faiss-gpu
# pip install faiss-gpu
```
#### 2. 编写 Python 代码
```python
import os
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI, OpenAIEmbeddings
from langchain_core.prompts import FewShotPromptTemplate, PromptTemplate
from langchain.prompts.example_selector import SemanticSimilarityExampleSelector
from langchain_community.vectorstores import FAISS
load_dotenv()
# 初始化模型和嵌入模型
chat_model = ChatOpenAI(model="gpt-3.5-turbo")
embeddings = OpenAIEmbeddings()
# 1. 创建一个大的示例池（我们的“图书馆”）
examples = [
    {"input": "如何创建一个空列表？", "output": "my_list = []"},
    {"input": "如何向列表添加元素？", "output": "my_list.append(item)"},
    {"input": "定义一个计算圆面积的函数", "output": "def calculate_circle_area(radius):\n    return 3.14 * radius * radius"},
    {"input": "如何遍历一个字典？", "output": "for key, value in my_dict.items():\n    print(key, value)"},
    {"input": "创建一个包含三个元素的字典", "output": "my_dict = {'a': 1, 'b': 2, 'c': 3}"},
    {"input": "如何从列表中移除一个元素？", "output": "my_list.remove(item)"},
    {"input": "定义一个带默认参数的函数", "output": "def greet(name, greeting='Hello'):\n    print(f'{greeting}, {name}!')"},
    {"input": "如何检查一个键是否在字典中？", "output": "if 'key' in my_dict:\n    print('Key exists')"},
    {"input": "创建一个类来表示一个学生", "output": "class Student:\n    def __init__(self, name, id):\n        self.name = name\n        self.id = id"},
    {"input": "如何对列表进行排序？", "output": "my_list.sort()"},
]
# 2. 创建 Example Selector（我们的“智能管理员”）
# 它会使用 FAISS 来进行高效的语义搜索
example_selector = SemanticSimilarityExampleSelector.from_examples(
    examples,          # 示例池
    embeddings,        # 用于将文本转换为向量的模型
    FAISS,             # 向量数据库，用于快速相似性搜索
    k=2,               # 为每个输入选择最相似的 2 个示例
)
# 3. 创建 FewShotPromptTemplate，但这次 examples 参数使用 selector
prompt_template = FewShotPromptTemplate(
    example_selector=example_selector,  # 动态选择示例
    example_prompt=PromptTemplate.from_template("用户需求: {input}\n代码示例: {output}"),
    prefix="你是一个专业的Python程序员。请根据用户的需求，参考提供的代码示例，生成相应的Python代码。",
    suffix="用户需求: {input}\n代码示例:",
    input_variables=["input"]
)
# 4. 创建链
chain = prompt_template | chat_model
# 5. 测试不同的用户输入
def test_and_explain(user_input):
    print(f"\n{'='*50}")
    print(f"用户输入: {user_input}")
    
    # 查看被选中的示例
    selected_examples = example_selector.select_examples({"input": user_input})
    print("\n--- 为该输入选择的示例 ---")
    for i, ex in enumerate(selected_examples):
        print(f"示例 {i+1}:")
        print(f"  需求: {ex['input']}")
        print(f"  代码: {ex['output']}")
    # 调用链并获取最终响应
    response = chain.invoke({"input": user_input})
    print("\n--- AI 生成的代码 ---")
    print(response.content)
# 测试案例1：与列表相关
test_and_explain("我该如何清空一个列表？")
# 测试案例2：与函数定义相关（语义匹配）
test_and_explain("写个函数算矩形周长")
# 测试案例3：与字典相关
test_and_explain("怎么获取字典里的值？")
```
---
### 运行结果与解析
#### 测试 1: "我该如何清空一个列表？"
```
==================================================
用户输入: 我该如何清空一个列表？
--- 为该输入选择的示例 ---
示例 1:
  需求: 如何创建一个空列表？
  代码: my_list = []
示例 2:
  需求: 如何向列表添加元素？
  代码: my_list.append(item)
--- AI 生成的代码 ---
my_list.clear()
```
**解析**：Selector 准确地识别出用户在问关于“列表”的操作，并选择了两个与列表最相关的示例。
#### 测试 2: "写个函数算矩形周长"
```
==================================================
用户输入: 写个函数算矩形周长
--- 为该输入选择的示例 ---
示例 1:
  需求: 定义一个计算圆面积的函数
  代码: def calculate_circle_area(radius):\n    return 3.14 * radius * radius
示例 2:
  需求: 定义一个带默认参数的函数
  代码: def greet(name, greeting='Hello'):\n    print(f'{greeting}, {name}!')
--- AI 生成的代码 ---
def calculate_rectangle_perimeter(width, height):
    return 2 * (width + height)
```
**解析**：这是最精彩的部分！用户的输入“算矩形周长”和示例池中的“算圆面积”在**语义上高度相似**（都是“定义一个几何计算函数”）。Selector 成功地捕捉到了这种语义，而不是简单的关键词匹配。
#### 测试 3: "怎么获取字典里的值？"
```
==================================================
用户输入: 怎么获取字典里的值？
--- 为该输入选择的示例 ---
示例 1:
  需求: 如何遍历一个字典？
  代码: for key, value in my_dict.items():\n    print(key, value)
示例 2:
  需求: 创建一个包含三个元素的字典
  代码: my_dict = {'a': 1, 'b': 2, 'c': 3}
--- AI 生成的代码 ---
value = my_dict['key']
```
**解析**：Selector 再次精准地找到了与“字典”操作相关的示例，为模型提供了绝佳的上下文。
---
### 总结：FAISS + Example Selector 的威力
1.  **动态与智能**：Prompt 不再是静态的，而是根据用户输入智能地构建。
2.  **高度可扩展**：你可以轻松地将 `examples` 列表扩展到成百上千条，而不用担心 Token 爆炸，因为每次只选择 `k` 个。
3.  **语义理解**：它超越了简单的关键词匹配，真正理解了用户意图的“含义”，从而选出最有效的示例。
4.  **性能与成本**：通过只提供最相关的示例，减少了无效信息的干扰，可能提升模型输出质量，同时节省了 API 调用成本。
这个组合是构建生产级、高质量 LLM 应用的关键技术之一，强烈建议掌握！

--------------------------------
以上内容由AI生成，仅供参考和借鉴